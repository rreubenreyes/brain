* THE ELEMENTS OF COMPUTING SYSTEMS - Noam Nisan and Shimon Schocken
*** Key Sections 

[[1-world-below][- The world below as we know it]]
[[1-hdl][- HDL]]
[[nand-project-01][- Project 01]]
[[nand-project-01][- Project 02]]

** Introduction 
This book teaches three things:

1. How computers work
2. How to break complex problems into manageable modules
3. How to develop large-scale hardware and software systems
   
We will be learning how to create a complete and working computer system, from the ground-up.

"/The only kind of learning which significantly influences behavior is self-discovered or self-appropriated--truth that has been assimilated in experience./"

*** The World Above 
Consider this trivial code:

#+BEGIN_SRC C
int main (void) {
  printf("%s", "Hello world!");
  return 0;
}
#+END_SRC

This is written in C. Newcomers often see the =void= or =%s= and ask what they mean, because they tend to be a bit too low level to understand at first glance.

What if I told you this wasn't even scratching the surface? For the computer to understand C, it must /parse/ the text, /uncover/ the semantics, and /reexpress it/ into something that can be understood by a computer. This step is known as *compilation*. C compiles down to assembly code, which compiles down to machine code.

Also, consider that /machine language itself is also an abstraction/. It is a set of binary codes that was designed to work specifically with the machine that is running the code. That is, it must be realized with a certain /chipset/ that is built using a specific system architecture. These chipset devices contain registers, memory units, ALU, and so on.

Going even deeper, realize that each of these devices is functionally held together by /logic gates/: Specific combinations of transistors that deterministically produce the same logical output if given the same logical input.

The nuances of any computer program, starting from the first transistor and leading up to the UX, start from the very bottom--the first transistor.

An intimate understanding of the world below is one of the things that separates naive programmers from sophisticated developers--people who can create complex /technologies/, not just /applications/ (of technologies that already exist).

*** Abstractions 
It is through building abstractions from the bottom up that we free up the mental capacity to actually go so far up.

We built the NAND gate, and we abstracted it away from our thoughts so that we could focus on other thing. This led to AND, which leads to OR, which leads to XOR, which leads to the adder... and so on. *A good abstraction focuses only on "What is this thing doing?" rather than "How does it do it?".

*** The World Below <<1-world-below>>
As we dive into the lands below, we'll find out more about the following...

**** High-Level Language Land 
**** The Road Down to Hardware Land
**** Hardware Land


** Chapter 1: Boolean Logic 
Every digital device is based on a set of chips designed to store and process information. They share the same common hardware: *Boolean logic gates*.

*** 1.1 - Background 
This chapter focuses on the construction of logic gates. To do this, we'll need to know some Boolean algebra!

**** 1.1.1 - Boolean Algebra 
There are two rules in Boolean algebra: Yes and no, /1 and 0/.

***** Truth tables 
The most common and simplest way to specify a Boolean function is to write a truth table, which graphically represents a given Boolean function's output for given input. They can also be represented as mathematical functions. See [[fig-1.1][Figure 1.1]].

+--------+--------+--------+--------+
|x       |y       |z       |f(x,y,z)|
+--------+--------+--------+--------+
|0       |0       |0       |0       |
+--------+--------+--------+--------+
|0       |0       |1       |0       |
+--------+--------+--------+--------+
|0       |1       |0       |1       |
+--------+--------+--------+--------+
|0       |0       |1       |0       |
+--------+--------+--------+--------+
|1       |0       |0       |1       |
+--------+--------+--------+--------+
|1       |0       |1       |0       |
+--------+--------+--------+--------+
|1       |1       |0       |1       |
+--------+--------+--------+--------+
|1       |1       |1       |0       |
+--------+--------+--------+--------+
/Figure 1.1: Truth table representation of a Boolean function =f(x, y, z) = (x + y) * z'=. <<fig-1.1>>/

***** Canonical representation 
Also called /minterm/ and /maxterm/:

- The /minterm/ is gathered by taking a truth table and Adding together literals whose combinations produce a function output of =1=,then Or-ing those terms together.
- The /maxterm/ is gathered by taking a truth table and doing the same thing, but in reverse order.

Doing either of these results in an expression that is equivalent to the logic expressed by the entire truth table. Using the canonical representation is a way to formulate a simple expression.

This also teaches us that *all Boolean functions can be built with =And=, =Or=, and =Not=.*

**** 1.1.2 - Gate Logic 
A /gate/ is a physical device that implements a Boolean function. Physically, a gate works by connecting I/O to I/O pins. The structure of the gate determines what the input/output of each pin should be to achieve a particular result. Gates are implemented today using /transistors/.

We begin our process of abstraction with gates.

***** Primitive and composite gates
A /composite gate/ is simply an implementation of a (usually more complex than normal) logical function through the use of two or more gates. For example, the three-input =And= is implemented by =And(And(a, b), c)=.

A gate /interface/ refers to dealing mainly with the gate's I/O, while gate /implementation/ deals with actually putting the circuit together using primitive gates. The only reason computer programmers really deal with gate implementation is to try to optimize low-level logic past what is currently possible in a given system. Meaning, the only requirement a computer programmer needs out of working with gates is the guarantee that all gates of the same type will produce the same results, with the same interface.

**** 1.1.3 - Actual hardware construction 
While it is easy to chain together primitive gates to arrive at simpler composite gate designs, testing the logical function of these gates quickly becomes physically unviable if we were to be building these gates ourselves. This is why we use virtual tools like /HDL (Hardware Description Language)/ and /VHDL (Virtual HDL)/.

**** 1.1.4 - Hardware Description Language (HDL) <<1-hdl>>
<2019-01-15 Tue 11:50>
HDL/VHDL is a fancy way to imply that "we test our circuits in a simulation environment". HDL is the standard by which many gates are tested before fabrication, and is the first language abstraction we have run into so far.

***** Guts of a HDL program  
There are a few parts to an HDL program:

****** Header 
The /header/ section specifies the chip /interface/ (=CHIP=). It specifies the chip name and the names of all input and output pins.

****** Parts 
The /parts/ (=PARTS=) section describes the names and topology of all the lower-level parts (other chips) from which this particular chip is constructed. Each part is represented by a /statement/ that specifies this part name, and crucially, the way it is connected to the other parts of the design.

Inter-part connections are described by creating and connecting /internal pins/ as needed. All =PARTS= connections are passed into gate interfaces as needed. See [[1-fig-1.6a][Figure 1.6a]] for an implementation of HDL to construct a XOR gate.

#+BEGIN_SRC
/* Xor.hdl */
CHIP Xor {
  IN a, b; /* these are external */
  OUT out; /* same */
  PARTS:
    Not(in=a, out=nota); /* using a new internal pin `nota` */
    Not(in=b, out=notb); /* the fact that `Not` has input pin `in` is an API specification */
    And(a=a, b=notb, out=w1);
    And(a=nota, b=b, out=w2);
    Or(a=w1, b=w2, out=out);
}
#+END_SRC
/Figure 1.6a: A =Xor= gate implemented in HDL./ <<1-fig-1.6a>>

****** Testing 
HDL scripts are contained within file extension =.hdl=, while tests are contained within =.tst=. A test script simply assigns binary inputs to the chip interface and produces the logical output file to a =.out= file, as a truth table. The syntax is as follows ([[1-fig-1.6b][Figure 1.6b]]).

#+BEGIN_SRC
load Xor.hdl,
output-list a, b, out; 
set a 0, set b 0;
eval, output;
set a 0, set b 1;
eval, output;
set a 1, set b 0;
eval, output;
set a 1, set b 1;
#+END_SRC
/Figure 1.6b: A =Xor= gate test, =Xor.tst=./ <<1-fig-1.6b>>

**** 1.1.5 -  Hardware Simulation 
Since HDL is a hardware construction /language/, the process of writing and debugging HDL programs is pretty much the same as in software development. If we were using a compiled language like C, we would send our raw code to a compiler to be translated into assembly. Instead, however, we use a /hardware simulator/.

A hardware simulator is also a computer program... it's really just a HDL compiler, but the purpose of HDL is very specific, hence the name of the compiler. 

*** 1.2 - Specification 
Now we will specify a typical set of gates, each designed to carry out a common Boolean operation. We will be following these gates all the way to the design of a modern computer!

**** 1.2.1 - Nand 
The truth table specification is as follows:
+-----+-----+----------+
|a    |b    |Nand(a, b)|
+-----+-----+----------+
|0    |0    |1         |
|0    |1    |1         |
|1    |0    |1         |
|1    |1    |0         |
+-----+-----+----------+

The API specification is as follows:
#+BEGIN_SRC
Chip name: Nand
Inputs:    a, b
Outputs:   out
Function:  If a=b=1 then out=0 else out=1
Comment:   This gate is considered primitive and thus there is no need to implement it.
#+END_SRC

**** 1.2.2 - Basic Logic Gates 
Here is the API specification for other basic logic gates.

***** Not 
#+BEGIN_SRC
Chip name: Not
Inputs:    in
Outputs:   out
Function:  If in=0 then out=1 else out=0
#+END_SRC

***** And 
#+BEGIN_SRC
Chip name: And
Inputs:    a, b
Outputs:   out
Function:  If a=b=1 then out=1 else out=0
#+END_SRC

***** Or 
#+BEGIN_SRC
Chip name: Or
Inputs:    a, b
Outputs:   out
Function:  If a=1 or b=1 then out=1 else out=0
#+END_SRC

***** Multiplexor 
#+BEGIN_SRC
Chip name: Mux
Inputs:    a, b, sel
Outputs:   out
Function:  If sel=0 then out=a else out=b
#+END_SRC

A multiplexor is a three-input gate that uses one of the inputs as a /selection bit/, and picks either =a= or =b= as its output depending on that selection bit. (=a= and =b= are usually the result of other input functions!)

***** Demultiplexor 
#+BEGIN_SRC
Chip name: DMux
Inputs:    in, sel
Outputs:   a, b
Function:  If sel=0 then {a=in, b=0} else {a=0, b=in}
#+END_SRC
A demultiplexor is similar in that it takes in a single input plus a selection bit, then produces two outputs. One of the outputs (=a= or =b=) is then assigned the value of =in= depending on the value of =sel=.

**** 1.2.3 - Multi-Bit Versions of Basic Gates 
Today, computer hardware is typically designed to operate on multi-bit arrays, not just single bits. These are called /buses/. A 32-bit bus, for example, simply operates on 32 bits at once, taking in 32 inputs from an input bus, and outputting another 32 bits. The buses do not incorporate multiple gates /in series/, but rather /in parallel/, so that outputs are all individual.

**** 1.2.4 - Multi-Way Versions of Basic Gates 
An /n-way/ gate, on the other hand, /does/ wire primitive gates in series. An /8-way =Or= gate/, for example, has eight input pins, =in[8]=, and produces a single output if any of those input pints are set to =1=.

***** The M-Way/N-Bit Multiplexor 
Multiplexors used multi-bit multi-way are essential in constructing computer platforms. Let's break it down:

A *16-bit multiplexor* consists of an input =in[16]= plus selection bit =sel=, and an output =out[16]=:
#+BEGIN_SRC
Chip name: Mux4 
Inputs:    in[16], sel
Outputs:   out[16]
Function:  If sel=0 then for i=0...15 out[i]=a[i] ... else out[i]=b[i]
#+END_SRC

A *4-way multiplexor* consists of an input =in[4]= plus two selection bits, corresponding to the number of possible input permutations, and a single output:
#+BEGIN_SRC
Chip name: Mux4Way 
Inputs:    in[4], sel0, sel1
Outputs:   out
Function:  If Nand(sel0, sel1) then out=in[0], if sel0, Not(sel1) then out=in[1] ... etc. 
#+END_SRC

A *16-bit, 4-way multiplexor* consists of four 16-bit inputs =a[16], b[16], c[16], d[16]= plus two selection bits and an output =out[16]=:
#+BEGIN_SRC
Chip name: Mux4Way16 
Inputs:    a[16], b[16], c[16], d[16], sel[2]
Outputs:   out[16]
Function:  If sel=00 then out=a, if sel=01 then out=b, ... etc. 
#+END_SRC
Note what is special about this chip: *It takes 4 possible 16-bit inputs, and turns it into one 16-bit output.* The usefulness of a selection bit is now much more obvious!

*** 1.3 - Implementation 
Primitive gates are our elementary building blocks. In particular, we will build an entire computing system off of just one primitive gate: =Nand=. The following primitive gates can be build using just Nand: =Nand -> Not -> And -> Or/Xor -> Mux/DMux -> Multi-bit primitives -> Multi-bit Mux -> Multi-way=

*** 1.4 & 1.5 - Perspective and Project 
We use =Nand= as our single primitive as a means of teaching, though it is not the only way to build computer systems from the ground up. We can study /digital design/ or /logic design/ for more in-depth knowledge.

**** Project 01 <<nand-project-01>>
([[file:~/git-repos/nand2tetris/01][completed project files)]]

- OBJECTIVE :: Implement all the logic gates presented in the chapter. The only building blocks that you can use are primitive Nand gates and the composite gates that you will gradually build on top of them.
- RESOURCES :: Use the hardware simulator provided by /nand2tetris/. All chips should be implemented in HDL, with accompanying tests. Some HDL files or test files are missing, and it is our job to figure out how to re-implement those.
- CONTRACT :: When loaded into the hardware simulator, our chip design should produce the outputs listed in the supplied =.cmp= file.
- STEPS ::
- Read Appendix A1 - A6.
- Go through the /hardware simulator tutorial/ parts I, II, and III.
- Build and simulate all the chips specified in =projects/01=.
 
<2019-01-16 Wed>
***** DONE Project log
CLOSED: [2019-01-16 Wed 08:52]

****** DONE And 
CLOSED: [2019-01-15 Tue 15:34]

******* =builtIn= directory must be relative to a script's root directory or included in the script folder itself 

****** DONE Or 
CLOSED: [2019-01-15 Tue 15:31]
****** DONE Xor 
CLOSED: [2019-01-15 Tue 16:25]
******* scratch
#+BEGIN_SRC
MINTERM a'b + ab' = f(a, b)
#+END_SRC

****** DONE Mux 
CLOSED: [2019-01-15 Tue 16:25]
******* scratch
#+BEGIN_SRC
ALIAS sel = s
MINTERM: f(a, b, s) = a'bs + ab's' + abs' + abs
DISTRIBUTIVE: 
  f(a, b, s) = a'bs + a(b's' + bs' + bs)
             = a'bs + a(b(s + s') + b's')
             = a'bs + a(b + b's')
             = a'bs + ab + ab's'
             = as' + bs
#+END_SRC

****** DONE DMux 
CLOSED: [2019-01-15 Tue 20:23]
******* scratch
#+BEGIN_SRC
IN: in, sel
OUT: a, b
ALIAS x = in
ALIAS y = sel
MINTERMS(a): xy'
MINTERMS(b): xy
#+END_SRC

*minterms/maxterms can be isolated by output and then superimposed*
****** DONE And16 
CLOSED: [2019-01-15 Tue 20:35]
****** DONE Or16 
CLOSED: [2019-01-15 Tue 20:37]
****** DONE Mux16 
CLOSED: [2019-01-15 Tue 20:40]
****** DONE Mux4Way16 
CLOSED: [2019-01-16 Wed 08:30]

******* scratch
*logic design involves a lot of looking for bitwise patterns and applying gradual abstractions*

****** DONE Mux8Way16 
CLOSED: [2019-01-16 Wed 08:36]
****** DONE DMux4Way 
CLOSED: [2019-01-16 Wed 08:46]
****** DONE DMux8Way 
CLOSED: [2019-01-16 Wed 08:52]

*** Appendix A (A1 - A6): Hardware Description Language (HDL) 

**** A.1 - HDL Program Example 
[[a1-fig-a.1][Figure A.1]] specifies a chip that accepts two three-bit numbers and outputs whether they are equal or not.

#+BEGIN_SRC
Chip name: Eq3
Inputs:    a[3], b[3]
Outputs:   out
Function:  If a=b then out=1 else 0

CHIP Eq3 {
  IN a[3], b[3];
  OUT out;
  PARTS:
    Xor(a=a[0], b=b[0], out=c0); 
    Xor(a=a[1], b=b[1], out=c1);
    Xor(a=a[2], b=b[2], out=c2);
    Or(a=c0, b=c1, out=c01); /* check if first bit and second bit are equal */
    Or(a=c01, b=c2, out=neq); /* check if first, second, third bit are equal */
    Not(in=neq, out=out);
}
#+END_SRC
/Figure A.1. <<a1-fig-a.1>>/

***** HDL API 
Ths HDL bundled with the book contains a standard library =builtIn=. Parts can be referenced from this library by using =BUILTIN [built-in component]=.




** Chapter 2: Boolean Arithmetic
[2019-01-16 Wed 18:25]

In this chapter we build gate logic designs that represent numbers /and perform arithmetic operations on them/. We will go from all the basic gates we did in chapter 1, all the way to an *Arithmetic Logic Unit (ALU)* at the end of the chapter! In the following chapters we will build up to a fully functioning CPU.

*** Coursera Unit 2.1: Binary Numbers 
In previous chapters, we've worked only with turning boolean values into more boolean values. However, binary can be used to represent "normal" arithmetic just as in decimal or other number systems. 

*** Coursera Unit 2.2: Binary Addition 
(this is fundamental and for the most part i know all of this)

*** Coursera Unit 2.3: Negative Numbers 
We know that an =n=-digit /unsigned/ binary number can represent =2^n= values. For example, a 3-bit bus can have 8 (=2^3=) possible values. 

That happens to be the same for /signed/ binary numbers. All we have to do is look at the leftmost bit; if it's =1=, then the number is negative, else it's positive.

**** 2's complement - Calculating signed binary numbers 

***** Negation 
An =n=-bit negative number =-x= can be thought of as =2^n - x=.

***** Bitwise negation 
To negate a number in binary, we use *2's complement*. This is done by taking the /1's complement/ (flip all the bits) and adding 1:

#+BEGIN_SRC
3 = 0b0011
-3 = ^0b0011
   = 0b1100 + 1
   = 0b1101
#+END_SRC

*** Coursera Unit 2.4: ALU 
The ALU is the brain-child of John Von Neumann. In Von Neumann Architecture,

=[INPUT] -> [MEMORY] <-> [CPU: {ALU | CONTROL}] -> [OUTPUT]=

the ALU exists within the CPU and is a central part in communicating with a computer's memory and output.

**** ALU specification 
#+BEGIN_SRC
Chip name: ALU
Inputs:    in1, in2, f (where f is one of a family of pre-defined logical functions)
Outputs:   f(in1, in2)
Function:  Dependent on f
#+END_SRC

**** The Hack ALU 
We will be building a Hack Computer in this course, so let's build a Hack ALU!

Hack ALU specification:
#+BEGIN_SRC
Chip name: HackALU
Inputs:    x[16], y[16], zx, nx, zy, ny, f, no
Outputs:   out[16], zr, ng
Function:  Many pre-defined functions defined by control bits
#+END_SRC
:w

The six control bits =zx, nx, zy, ny, f, no= define a /directive/ for the Hack ALU. It will compute many functions based on their input; for example, =000111= tells the ALU to compute =y - x=.

**** Hack ALU control bits 
- =zx= - =if zx then x\=0=
- =nx= - =if nx then x\=!x=
- =zy= - =if zy then y\=0=
- =ny= - =if ny then y\=!y=
- =f= - =if f then out\=x+y else out\=x&y=
- =no= - ~if no then out\=!out~

The six control bits combine a /superposition/ of each of the functions specified by each bit. That is: =F(x, y) = z(x) + n(x) + z(y) + n(y) + f(x, y)=. This means that *the Hack ALU can compute any of 64 different function combinations.*

***** Example: Compute !x 
- IN :: ~x=0b1100~ ~y=1011~
- CONTROL BITS :: =001101=
                  
#+BEGIN_SRC
n(x) = 0: x = 1100
z(x) = 0: x = 1100
n(y) = 1: y = 0000
z(y) = 1: y = 1111
f(x, y) = 0:
  x & y = 1100
no = 1: out = 0011 === !x
#+END_SRC 

***** Caveat 
The ALU is just an implementation /of an abstraction/ of the previous basic logic gates we've created before. There is nothing too magical about it, other than the fact that somebody decided to combine a bunch of (very useful) bitwise functions into one unit.

**** Output control bits 
- =zr= - ~if out=0 then zr=1 else 0~
- =ng= - ~if out<0 then ng=1 else 0~

***** Caveat 
This becomes important a bit later down the line when we build a CPU!

**** Perspective 
The Hack ALU is ideal for teaching purposes because of its simplicity, elegance, and ease of implementation. The bitwise functions it covers are fairly straightforward; they are visibly based off of early abstractions.

As we said before, the ALU is just putting a bunch of our previous chips into one chip!

*** Project 02 <<nand-project-02>>
- GIVEN :: All the chips built in Project 01!
- OBJECTIVE :: Build the a =HalfAdder=, =FullAdder=, =Add16=. =Inc16=, and =ALU=.
  - Note that these chips are all computational chips, going from simple to more complex.
  - Going from our previous example, we can see the trends we've been emphasizing regarding computational chips being simple extensions of basic logic gates. For example:
    - A =HalfAdder= has two outputs, =sum= and =carry=. Its truth table indicates that it can be implemented with just two basic chips: ~sum(a, b) = Xor(a, b)~ and ~carry(a, b) = And(a, b)~.

**** scratch 
***** HalfAdder 
+-----+-----+-----+-----+
|a    |b    |sum  |carry|
+-----+-----+-----+-----+
|0    |0    |0    |0    |
|0    |1    |1    |0    |
|1    |0    |1    |0    |
|1    |1    |0    |1    |
+-----+-----+-----+-----+
#+BEGIN_SRC
MINTERMS(sum):   a'b + ab'
MINTERMS(carry): ab
#+END_SRC
 
***** FullAdder 
+-----+-----+-----+-----+-----+
|a    |b    |c    |sum  |carry|
+-----+-----+-----+-----+-----+
|0    |0    |0    |0    |0    |
|0    |0    |1    |1    |0    |
|0    |1    |0    |1    |0    |
|0    |1    |1    |0    |1    |
|1    |0    |0    |1    |0    |
|1    |0    |1    |0    |1    |
|1    |1    |0    |0    |1    |
|1    |1    |1    |1    |1    |
+-----+-----+-----+-----+-----+
#+BEGIN_SRC
MINTERMS(sum):   a'b'c + a'bc' + ab'c' + abc
MINTERMS(carry): a'bc + ab'c + abc' + abc
#+END_SRC

***** Add16 (16-bit adder)
***** Inc16 (16-bit incrementor)
***** ALU 




