<2019-01-14 Mon 13:09>
* THE ALGORITHM DESIGN MANUAL - Steven Skiena
** Chapter 1: Introduction to Algorithm Design
**** What is an algorithm?
*An algorithm is a procedure to accomplish a specific task.* More specifically, an algorithm must solve a general, well-specified problem.
    
***** Problem 1: Sorting
- INPUT :: A sequence of ~n~ keys, ~a_1, ... , a_n~
- OUTPUT :: The permutation of the input sequence such that ~a'_1 <= a'_2 <= ... <= a'_{n-1} <= a'_n~

An example of an /instance/ of sorting might be an array of any sort of data type (~const arr: number[] = [1, 2, 3]~). However, given that instance (of numbers), we now know that we are dealing with... only that instance of numbers. This problem has several possible /input instances/.l

**** Algorithms: Three desirable properties
We seek algorithms that are:

1. /correct/
2. /efficient/
3. /easy to implement/

*** 1.1
**Take-Home Lesson**: Heuristics aren't algorithms

*** 1.2
**Take-Home Lesson**: A correct-looking algorithm isn't always correct. Reason about all your tools and demonstrate an algorithm's correctness first.

*** 1.3 - Reasoning About Correctness
The most demonstrable way we have to prove the correctness of our algorithms is called a /proof/, which has several parts:

1. A clear, precise statement of what you are trying to prove.
2. A set of assumptions of things which are taken to be true, and hence used as part of the proof.
3. A little square (QED) denoting that you have finished.

Proofs are simply /honest arguments explaining why an algorithm satisfied a nontrivial correctness property./

**** 1.3.1 - Expressing Algorithms
The three most common forms of algorithmic notation are:

1. English
2. Pseudocode
3. A real programming language

All three can prove useful because of the tradeoff in readability/expressiveness carried by each choice.

**Take-Home Lesson** The heart of any algorithm is an /idea/, If your idea is not clearly revealed when you an express an algorithm, then you are using too low-level a notation to describe it.

**** 1.3.2 - Problems and Properties
***** Problem specifications
Problem specifications have two parts:

1. The set of allowed input instances, and
2. The required properties of the algorithm's output.

It's impossible to prove the correctness of an algorithm if we don't even know what our solution is going to be working with or putting out. /Ask the wrong problem, and you will get the wrong answer/.

Some problem specifications allow too much variety in input instances; these problems are /too general/ and it's likely that no solution exists. On the other hand, some specifications are too specific, and define an impossible question by their definition.

***** Common pitfalls in algorithm design
1. Asking an ill-defined question: "What is the /best/ way to do this?" What does /"best"/ even mean?
2. Creating compound goals (keep yo

**** 1.3.3 - Demonstrating Incorrectness 
***** The best way to prove that an algorithm is incorrect is to produce an instance of an incorrect answer.
No rational person will ever leap to the defense of an algorithm after a counter-example has been identified. Good counter-examples have two important properties:

****** Verifiability
To demonstrate that you've named an actual counter-example, you must be able to:

1. Calculate what answer your algorithm will give in some instance
2. Display a better answer so as to prove that the algorithm didn't find it

Since you are reasoning about a given counter-example's instance, it should be kept simple!

****** Simplicity 
As in, all unnecessary details should be gone. Think about the last StackOverflow question you saw with a terrible problem description? How should you be able to prove that an algorithm is incorrect if nobody can understand your counter-example?  

***** TODO Hunting for counter-examples



